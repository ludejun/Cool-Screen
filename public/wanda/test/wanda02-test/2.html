<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>02</title>
<script type="text/javascript" src="../../jquery/jquery-2.0.0.min.js"></script>
<script type="text/javascript" src="../../js/mt.js"></script>
<script type="text/javascript" src="../../js/ani.js"></script>
<script type="text/javascript" src="../../js/gd.js"></script>
<script type="text/javascript" src="js/main.js"></script>
<style type="text/css">

body{
	background-color: #333;
}
canvas{
	background-color: #000;
}


</style>
</head>
<body>


<canvas width="1200" height="600"></canvas>

<script type="text/javascript">


var canvas = document.querySelector('canvas');
var ctx = canvas.getContext('2d');


var points = [
	{x:290, y:200},
	{x:590, y:100},
	{x:500, y:200},
	{x:100, y:-100},
	{x:0, y:0},
	{x:150, y:0},
	{x:100, y:-100},
	{x:150, y:100},
	{x:200, y:100},
	{x:300, y:200}
];

function getCenterPoint(p0, p1){
	return {
		x: p0.x + (p1.x - p0.x) * .5,
		y: p0.y + (p1.y - p0.y) * .5
	}
}

function getCenterPoints(points, end){
	var ps = [];
	for(var i = 1; i < points.length; i++){
		ps.push(getCenterPoint(points[i - 1], points[i]));
	}
	end && ps.push(getCenterPoint(points[points.length - 1], points[0]));
	return ps;
}

function getAngle(a, b){
	var A = Math.atan2(b.y - a.y, b.x - a.x);
	if(A < 0){
		A += Math.PI * 2;
	}
	// if(A < 0) A += Math.PI * 2;
	return A;
}
var A1 = Math.PI / 180;
var A90 = Math.PI / 2;
var A60 = Math.PI / 3;
var A120 = Math.PI * 2 / 3;
function logAngle(){
	var arr = [];
	for(var i = 0; i < arguments.length; i++){
		arr.push(Math.round(arguments[i] / (Math.PI / 180)));
	}
	console.log(arr);
}
function getCvPreHandle(pa, po, pb, weight){
	var A = getAngle(pa, po), B = getAngle(pb, po);
	if(B < A){
		B += Math.PI * 2;
	}
	var C = (A + B) / 2;
	var a = GD.distance(pa, po) * weight;
	var b = GD.distance(pb, po) * weight;
	var ra = Math.pow(b / (a + b), 1), rb = 1 - ra;

	ra = 0.5;
	rb = 0.5;

	return [{
		x: a * Math.cos(C + Math.PI * ra) + po.x,
		y: a * Math.sin(C + Math.PI * ra) + po.y
	}, {
		x: b * Math.cos(C - Math.PI * rb) + po.x,
		y: b * Math.sin(C - Math.PI * rb) + po.y
	}]
}

function getCvPoint2(points, weight){

	weight = weight || 0.2;
	var _cvs = [];
	for(var i = 2; i < points.length; i++){
		_cvs.push(getCvPreHandle(points[i - 2], points[i - 1], points[i - 0], weight));
		drawPoints(ctx, _cvs[_cvs.length - 1], 'rgba(255,255,0,0.5)');
		drawLines(ctx, _cvs[_cvs.length - 1], 'rgba(255,255,0,0.5)');
	}

	var cvs = [];

	for(var i = 1; i < points.length - 2; i++){
		cvs.push([points[i], _cvs[i - 1][1], _cvs[i][0], points[i + 1]]);
	}
	cvs.unshift([points[0], _cvs[0][0], points[1]]);
	cvs.push([points[points.length - 2], _cvs[_cvs.length - 1][1], points[points.length - 1]]);
	

	// console.log(cvs);

	return cvs;

	// var cps = getCenterPoints(points);
	// drawPoints(ctx, cps, '#ff0');
}

function drawCv(ctx, data){
	ctx.beginPath();
	MT.EACH(data, function(cv){

		ctx.moveTo(cv[0].x, cv[0].y);
		if(cv.length == 3){
			ctx.quadraticCurveTo(cv[1].x, cv[1].y, cv[2].x, cv[2].y);
		} else {
			ctx.bezierCurveTo(cv[1].x, cv[1].y, cv[2].x, cv[2].y, cv[3].x, cv[3].y);
		}
	});
	ctx.lineWidth = 2;
	ctx.strokeStyle = 'rgba(255,255,0,1)';
	ctx.stroke();
}


function getCvPoint(points){
	var weight = 0.8;
	var cps = getCenterPoints(points);
	var cs = [];
	for(var i = 1; i < points.length - 1; i++){
		var cp = getCenterPoint(cps[i - 1], cps[i]);
		var x = (points[i].x - cp.x);
		var y = (points[i].y - cp.y);
		cs.push([
			{ x: cps[i - 1].x + x, y: cps[i - 1].y + y },
			{ x: cps[i].x + x, y: cps[i].y + y }
		]);
		// drawLines(ctx, cs[cs.length - 1], '#fa0');
	}
	var cp = getCenterPoint(cps[cps.length - 1], cps[0]);
	var x = (points[0].x - cp.x);
	var y = (points[0].y - cp.y);
	cs.push([
		{ x: cps[cps.length - 1].x + x, y: cps[cps.length - 1].y + y },
		{ x: cps[0].x + x, y: cps[0].y + y }
	]);

	var cvs = [
		[points[0], points[0], cs[0][0], points[1]]
		// [points[0], cs[cs.length - 1][1], cs[0][0], points[1]]
	];
	for(var i = 1; i < points.length - 1; i++){
		cvs.push([points[i], cs[i - 1][1], cs[i][0], points[i + 1]])
	}
	cvs[cvs.length - 1][2] = points[points.length - 1];

	MT.EACH(cvs, function(cv){

		// drawPoints(ctx, cv, '#fa0');

		ctx.beginPath();
		ctx.moveTo(cv[0].x, cv[0].y);
		ctx.bezierCurveTo(cv[1].x, cv[1].y, cv[2].x, cv[2].y, cv[3].x, cv[3].y);
		ctx.strokeStyle = '#0af';
		ctx.lineWidth = 2;
		ctx.stroke();
	});

	return cvs;
}



function drawLines(ctx, arr, color, width){
	ctx.beginPath();
	ctx.moveTo(arr[0].x, arr[0].y);
	for(var i = 1; i < arr.length; i++){
		ctx.lineTo(arr[i].x, arr[i].y);
	}
	// ctx.closePath();
	ctx.lineWidth = width || 2;
	ctx.strokeStyle = color || '#fff';
	ctx.stroke();
}

function drawPoints(ctx, arr, color, radio){
	radio = radio || 5;
	color = color || '#fff';

	ctx.fillStyle = color;
	MT.EACH(arr, function(a){
		ctx.beginPath();
		ctx.arc(a.x, a.y, radio, 0, Math.PI * 2);
		ctx.fill();
	});
}

// drawPoints(ctx, getCenterPoints(points), '#00f');
ctx.translate(50, 130);
drawLines(ctx, points, null, 0.5);
drawCv(ctx, getCvPoint2(points, 0.2));
ctx.translate(50, 240);
drawLines(ctx, points, null, 0.5);
getCvPoint(points);


// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));
// drawLines(ctx, points = getCvPoint(points));



</script>


</body>
</html>